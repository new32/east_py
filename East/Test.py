#!/usr/bin/env python3

# Copyright (c) 2017, Arthur Gardiner
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
# OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import sys
import re
import math
import os
import datetime
"""
Base class for a test driver.

This class is intended to be subclassed to create a unit test driver. The basic
idea behind the OOP driver is to create your test suites as members of the
driver, each of which checking some elements of behavior, and attaching them as
desired. Since the test driver operates on the idea of methods as test suites,
setup and tear down operations can be created individually within the suites or
as functions of the driver.

Each suite within a driver has an internal limit of 65535 checks it can perform.
This limit exists only to ensure that each suite performs only a reasonable
number of operations.

The report format is an obvious nod to the Test Anything Protocol[1]
(https://testanything.org/tap-specification.html). Finding some shortcomings in
the current version __for my needs__, the following differences exist:

Only 6 keywords (PASS, FAIL, SKIP, STOP, PLAN, TEST) plus the comment marker (#)
are defined by the report format; Keywords and comments must appear at the start
of the line.

(Pass|Fail) CHECK_NUMBER - RESULT
Each line starting with a 'Pass' or 'Fail' entry represents a particular check
as denoted by CHECK_NUMBER (autogenerated by the 'check*' calls).
For the 'check' calls, RESULT provides a quick look at the expected and actual
values (including the provided tolerance for floating point comparisons).
For the 'checkArray' calls, RESULT provides a quick look at the number of
expected entries vs the number of matched values. If a failure occurs, the first
mismatch is also listed. If either the expected or actual does not contain
enough elements to compare, that mismatch will be listed before any comparison
occurs.
For 'checkDie' calls, RESULT will either be 'Ok' on a Pass or 'Not Ok' on a
failure.
These must appear before the 'Stop', 'Plan' or 'Test' lines.

Skip TEST_NUMBER
Each line starting with a 'Skip' is a disabled check. Comments should be
added to identify why a check has been skipped. Skipped checks add to the total
check count but otherwise perform no evaluations of the results or
additional bookkeeping.
These must appear before the 'Stop', 'Plan' or 'Test' lines.

Stop - REASON
A line starting with 'Stop' indicates the test suite has either crashed, REASON
will be the signal that caused the crash, or a 'die' has resulted in a failure
and the appropriate reason given (if provided, defaults to "...died...").
If needed, this must appear after 'Pass', 'Fail' or 'Skip' lines and before the
'Plan' or 'Test' lines.

Plan 1..COUNT
The 'Plan' line simply states how many checks have been executed by the suite.
If the test suite is stopped by a crash or 'die', will be 'Plan 1..0'.
This line must appear after 'Pass', 'Fail', 'Skip' or 'Stop' and before 'Test'.

Test SUITE_NUMBER STATUS
The 'Test' line indicates the overall result of a particular test suite as
denoted by SUITE_NUMBER (autogenerated by the driver based on order of
execution). STATUS is set to "Ok" if all tests within the suite pass (or are
skipped) and "Not Ok" if a failure or stop occurs.
This line must be the last line of the test suite's report, coming after all
keywords as it ends all reporting for the current test suite.

# COMMENT
A comment can appear anywhere preceeding the 'Stop', 'Plan' and 'Test' lines.

[1] TAP is awesome and has several libraries for multiple languages available.
This project is not endorsed by the folks at TAP. However, consider this my
endorsement of them :)

A basic template for subclasses:

#!/usr/bin/env python3

import East

class MyDriver(East.Test):
  def __init__(self):
    super().__init__()
    self.add(self.suite1)
    self.run()

  def suite1(self):
    pass
"""
# ======================================================================
class StopException(Exception):
  """ Inner class to represent Stops of execution. """
  def __init__(self, message):
    self.message = message
# ======================================================================
class Test:
  def __init__(self):
    self._MAX_SIZE = 65535
    self.suites = list()
    self.suite_count = 0
    self.fout = sys.stdout
    self.failed_suites = list()
  # --------------------------------------------------------------------
  def _init(self):
    self.checks = 0
    self.failures = 0
  # --------------------------------------------------------------------
  def _increment_count(self, good, skip):
    if self.checks < self._MAX_SIZE:
      self.checks += 1
    if not skip:
      if (not good) and self.failures < self._MAX_SIZE:
        self.failures += 1
      label = "Pass" if good else "Fail"
    else:
      label = "Skip"
    label += " " + str(self.checks)
    return label
  # --------------------------------------------------------------------
  def _check(self, good, message):
    label = self._increment_count(good, False)
    label += " - " + message
    return label
  # --------------------------------------------------------------------
  def _is_feq(self, expected, actual, tolerance):
    return (math.fabs(expected - actual) <= tolerance)
  # --------------------------------------------------------------------
  def note(self, text):
    """
    Add documentation to the report.

    Each line of a multiline entry is automatically prepended with the
    comment marker.
    """
    lines = re.split("\r?\n", text)
    for line in lines:
      print("# " + line, file=self.fout)
  # --------------------------------------------------------------------
  def add(self, suite):
    """ Add a suite to execute if it's not in already queued. """
    if suite not in self.suites:
      self.suites.append(suite)
  # --------------------------------------------------------------------
  def remove(self, suite):
    """ Remove a previously queued suite. """
    if suite in self.suites:
      self.suites.remove(suite)
  # --------------------------------------------------------------------
  def checkDie(self, result, stop_text="...died..."):
    """ Issue a STOP when result is False. """
    label = self._increment_count(result, False) + " - "
    label += "Ok" if result else "Not Ok"
    print(label, file=self.fout)
    if not result:
      lines = re.split("\r?\n", stop_text)
      raise StopException(lines[0])
  # --------------------------------------------------------------------
  def check(self, expected, actual, skip=False, negate=False):
    """
    By default, verifies that expected == actual.

    If negate is enabled, verifies that expected != actual.
    If skip is enabled, no check is performed and a SKIP is issued.
    """
    if not skip:
      if negate:
        message = "(NE) E:" + str(expected)
        message += ", A:" + str(actual)
        good = expected != actual
      else:
        message = "(EQ) E:" + str(expected)
        message += ", A:" + str(actual)
        good = expected == actual
      label = self._check(good, message)
    else:
      label = self._increment_count(True, skip)
    print(label, file=self.fout)
  # --------------------------------------------------------------------
  def checkFloat(self, expected, actual, tolerance=0.0001, skip=False, negate=False):
    """
    By default, verifies that expected == actual.

    Tolerance is used to determine precision due to rounding of floating point
    values.
    If negate is enabled, verifies that expected != actual.
    If skip is enabled, no check is performed and a SKIP is issued.
    """
    if not skip:
      if negate:
        message = "(NE) E:" + str(expected)
        message += ", A:" + str(actual)
        message += ", T:" + str(tolerance)
        good = not self._is_feq(expected, actual, tolerance)
      else:
        message = "(EQ) E:" + str(expected)
        message += ", A:" + str(actual)
        message += ", T:" + str(tolerance)
        good = self._is_feq(expected, actual, tolerance)
      label = self._check(good, message)
    else:
      label = self._increment_count(True, skip)
    print(label, file=self.fout)
  # --------------------------------------------------------------------
  def checkArray(self, expected_list, actual_list, count, skip=False):
    """
    Verifies that all elements of expected are in actual.

    If the lists have different lengths, a failure occurs.
    If skip is enabled, no check is performed and a SKIP is issued.
    """
    if not skip:
      good = True
      e_len = len(expected_list)
      a_len = len(actual_list)
      if e_len >= count and a_len >= count:
        idx = 0
        while idx < count and good:
          good = expected_list[idx] == actual_list[idx]
          idx += 1

        message = "(EQ) Expected:" + str(count)
        if good:
          message += ", Matched:" + str(idx)
        else:
          message += ", Checked:" + str(idx)
          message += ", Mismatched at " + str(idx)
      else:
        good = False
        message = "(EQ) E Length:" + str(e_len)
        message += ", A Length:" + str(a_len)
        message += ", Elements To Check:" + str(count)
      label = self._check(good, message)
    else:
      label = self._increment_count(True, skip)
    print(label, file=self.fout)
  # --------------------------------------------------------------------
  def checkFloatArray(self, expected_list, actual_list, count, tolerance=0.0001, skip=False):
    """
    Verifies that all elements of expected are in actual.

    Tolerance is used to determine precision due to rounding of floating point
    values.
    If the lists have different lengths, a failure occurs.
    If skip is enabled, no check is performed and a SKIP is issued.
    """
    if not skip:
      good = True
      e_len = len(expected_list)
      a_len = len(actual_list)
      if e_len >= count and a_len >= count:
        idx = 0
        while idx < count and good:
          good = self.is_feq(expected_list[idx], actual_list[idx], tolerance)
          idx += 1

        message = "(EQ) Expected:" + str(count)
        if good:
          message += ", Matched:" + str(idx)
        else:
          message += ", Checked:" + str(idx)
          message += ", Mismatched at " + str(idx)
      else:
        good = False
        message = "(EQ) E Length:" + str(e_len)
        message += ", A Length:" + str(a_len)
        message += ", Elements To Check:" + str(count)
      label = self._check(good, message)
    else:
      label = self._increment_count(True, skip)
    print(label, file=self.fout)
  # --------------------------------------------------------------------
  def run(self, out_file=""):
    """
    Execute all queued suites, printing a report upon completion.

    If no report is passed, the driver script name is used appended by
    "_rpt.txt" for the report name.

    In addition to the suite results, a summary is printed at the bottom of
    each report, indicating the overall status of the run as well as the end
    time of the script's execution.

    If a report cannot be created, standard out is used.
    """
    if not out_file or out_file == "":
      out_file = sys.argv[0]+"_rpt.txt"

    try:
      self.fout = open(out_file, "w")
    except OSError as err:
      self.fout = sys.stdout

    for tc in self.suites:
      self._init()
      self.suite_count += 1
      has_exception = False
      try:
        tc()
      except StopException as SE:
        print("Stop - " + str(SE), file=self.fout)
        has_exception = True
      except Exception as BE:
        message = BE.__class__.__name__ + ": " + str(BE)
        print("Stop - " + message, file=self.fout)
        has_exception = True
      if has_exception:
        self.checks = 0
        self.failures = 1
      print("Plan 1.." + str(self.checks), file=self.fout)
      suite_name = "Test %d" % self.suite_count
      message = suite_name + (" Not Ok" if self.failures else " Ok") + "\n"
      if "Not Ok" in message:
        self.failed_suites.append(suite_name)
      print(message, file=self.fout)

    if self.failed_suites:
      self.note("The following suites contain failures:")
      for failure in self.failed_suites:
        self.note("  "+failure)
    else:
      self.note("All suites Ok!")
    self.note("")
    self.note(os.path.abspath(sys.argv[0]))
    self.note("executed: " + datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

    if self.fout != sys.stdout:
      self.fout.close()
